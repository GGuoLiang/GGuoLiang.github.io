<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://gguoliang.github.io</id>
    <title>GGuoLiang</title>
    <updated>2020-04-23T07:11:01.237Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://gguoliang.github.io"/>
    <link rel="self" href="https://gguoliang.github.io/atom.xml"/>
    <subtitle>GGuoLiang 莫听穿林打叶声</subtitle>
    <logo>https://gguoliang.github.io/images/avatar.png</logo>
    <icon>https://gguoliang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, GGuoLiang</rights>
    <entry>
        <title type="html"><![CDATA[IO流]]></title>
        <id>https://gguoliang.github.io/post/io-liu/</id>
        <link href="https://gguoliang.github.io/post/io-liu/">
        </link>
        <updated>2020-04-23T06:53:57.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="io流">IO流</h2>
]]></summary>
        <content type="html"><![CDATA[<h2 id="io流">IO流</h2>
<!-- more -->
<table>
<thead>
<tr>
<th>分类</th>
<th>字节输入流</th>
<th>字节输出流</th>
<th>字符输入流</th>
<th>字符输出流</th>
</tr>
</thead>
<tbody>
<tr>
<td>抽象基类</td>
<td>InputStream</td>
<td>OutputStream</td>
<td>Reader</td>
<td>Writer</td>
</tr>
<tr>
<td>缓冲流</td>
<td>BufferedInputStream</td>
<td>BufferedOutputStream</td>
<td>BufferedReader</td>
<td>BufferedWriter</td>
</tr>
<tr>
<td>文件流</td>
<td>FileInputStream</td>
<td>FileOutputStream</td>
<td>FileReader</td>
<td>FileWriter</td>
</tr>
<tr>
<td>转换流</td>
<td></td>
<td></td>
<td>InputStreamReader</td>
<td>OutputStreamWriter</td>
</tr>
<tr>
<td>打印流</td>
<td></td>
<td>PrintStream</td>
<td></td>
<td>PrintWriter</td>
</tr>
<tr>
<td>数据流</td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
<td></td>
<td></td>
</tr>
<tr>
<td>对象流</td>
<td>ObjectInputStream</td>
<td>ObjectOutputStream</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<!-- more -->
<h3 id="file-类">file 类</h3>
<ol>
<li>file类的一个对象代表一个文件和一个文件目录</li>
<li>file类声明在java.io包下</li>
<li>file类中的涉及到了关于的文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或者读取文件的内容的操作。如果需要读取内容或者是 写入文件内容就需要使用IO流来完成。</li>
<li>file类的对象常常会作为参数传递到流的构建当中，指明读取或者写入的“终点”。</li>
</ol>
<h3 id="io流-2">IO流</h3>
<p>处理设备之间的数据传输</p>
<p>流向区分</p>
<p>输入流：读取外部数据到程序内存</p>
<p>输出流t：程序内存输出到外部</p>
<p>数据单位区分</p>
<p>字节流（8bit）：InputStream和OutputStream  图片，视频 非文本数据</p>
<p>字符流（16Bit）：Reader和Writer   char 为单位 ，适合文本数据</p>
<p>流的角色区分：</p>
<p>节点流：直接作用在文件之上的流（四个抽象基类 或者文件流）</p>
<p>处理流： 包裹处理的流</p>
<table>
<thead>
<tr>
<th></th>
<th>字节流（8bit）</th>
<th>字符流（16bit）</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入流</td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody>
</table>
<h4 id="节点流">节点流</h4>
<h5 id="filereader-和filewriter">FileReader 和FileWriter</h5>
<ol>
<li>
<p>read() ：返回读入的一个字符，如果到达文件末尾会返回一个-1</p>
</li>
<li>
<p>异常处理：使用try-catch-finally</p>
</li>
<li>
<p>流的关闭：close()</p>
</li>
<li>
<p>读取的文件必须存在，输出的文件不必存在，会自动创建。</p>
</li>
<li>
<p>输出操作时原有文件存在 注意输出流的构建器 append参数设置，append：true 原有文件追加操作 flase直接覆盖原有文件内容</p>
</li>
<li>
<p>不能使用字符流处理字节数</p>
</li>
</ol>
<h5 id="fileinputstream-和outputstream">FileInputStream 和OutPutStream</h5>
<p>使用与字符流差不多</p>
<h4 id="处理流">处理流</h4>
<h5 id="缓冲流">缓冲流</h5>
<ol>
<li>
<p>BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter</p>
</li>
<li>
<p>作用：提升流的读写速度。原因内部提供了一个缓冲区</p>
</li>
<li>
<p>先关闭外层的流 在关闭内层的流。但是在关闭外层的流时，会自动关闭内层的流。</p>
</li>
<li>
<p>flush（）：刷新缓存区</p>
</li>
<li>
<p>处理流：套接在已有流的基础上</p>
</li>
<li>
<p>readLine（）： 一次读一行</p>
</li>
<li>
<p>newLine（）：换行</p>
</li>
</ol>
<h5 id="转换流">转换流</h5>
<p>字节流转换为字符流</p>
<ol>
<li>
<p>InputStreamReader （InputStream转Reader，解码）OutputStreamWtiter（Wtiter转OutputStream流，编码）  属于字符流</p>
</li>
<li>
<p>解码：字节-字符  编码：字符-字节</p>
</li>
<li>
<p>字符集：构造器的字符集参数取决于存的时候使用的字符集</p>
</li>
</ol>
<h5 id="标准的输出-输入流">标准的输出、输入流</h5>
<p>Systeam.in:输入流 默认 键盘输入流（字节流）</p>
<p>Systeam.out：输出流  默认控制台输出</p>
<h5 id="打印流">打印流</h5>
<p>PrintStream PrintWriter（都是输出流）</p>
<p>提供print和println方法</p>
<h5 id="数据流">数据流</h5>
<p>DataInputStream DataOutputStream</p>
<p>用于读取和写入基本数据的变量和字符串</p>
<p>注：读取数据时要与写入顺序一致</p>
<h5 id="对象流">对象流</h5>
<p>你对象的序列化和反序列化</p>
<p>对象的序列化机制：允许吧内存中的java对象转换成平台无关的二进制流，从而把这种二进制流持续地保存在磁盘上；或者通过网络将这种二进制流传输到另一个 网络节点，当其他程序获取了这种二进制流，就可以恢复成原来的java对象。</p>
<p>自定义类是可序列化的</p>
<ol>
<li>需要实现接口 Serializable</li>
<li>当前类提供一个全局变量：serialVersionUID</li>
<li>处理当前自定的类实现序列化接口之外，还必须保证其内部所有属性也必须是可序列化的（默认情况下，基本数据类型可序列化）</li>
</ol>
<p>注;ObjectInputStream 和 ObjectOutputStream不能序列化static 和transient修饰的成员变量</p>
<h5 id="随机存取文件流">随机存取文件流</h5>
<p>RandomAccessFile   输出流  输入流  双向的  实现DataInput DataOutPut 类<br>
构造器 第二个参数mode 指定文件的访问模式<br>
r:以只读的方式打开、<br>
rw：读写、<br>
rwd：<br>
rws</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java对象和内存控制]]></title>
        <id>https://gguoliang.github.io/post/java-dui-xiang-he-nei-cun-kong-zhi/</id>
        <link href="https://gguoliang.github.io/post/java-dui-xiang-he-nei-cun-kong-zhi/">
        </link>
        <updated>2020-04-23T06:53:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="java对象和内存控制">Java对象和内存控制</h2>
<h3 id="内存管理">内存管理</h3>
<p>内存分配：在创建Java对象JVM在堆内存中所分配的空间；</p>
<p>内存回收：当Java对象失去引用，成为垃圾JVM的垃圾回收机制清理该对象，并回收该对象使用的内存。</p>
<p>由于Java的优点之一就是垃圾回收机制，会让Java开发者认为无需关注Java内存管理，其实不然如此。如果在开发Java程序的过程中肆无忌惮的挥霍Java的内存分配，会造成Java程序的运行效率低下。</p>
<p>JVM的垃圾回收机制是由一条的后台线程处理的，本事是非常消耗性能，如果肆无忌惮的创建Java对象，让系统进行分配，再将这些分配的内存回收会面临俩个问题：</p>
<blockquote>
<p>不断分配内存会使得系统的可用内存减少</p>
<p>大量已分配的内存回收使用垃圾回收机制负担加重</p>
</blockquote>
<h3 id="类变量和实例变量">类变量和实例变量</h3>
<p>static修饰的成员变量是类变量，属于该类本身；没有使用static修饰的成员变量是实例变量，属于该类的实例。在同一个JVM内，每个类只对应一个Class对象，但每个类可以创建多个Java对象。</p>
<p>JVM内每一个类对应一个class对象，因此同一个JVM内一个类的类对象只旭一块内存；但是对于实例变量，该类每创建一个实例对象就需要一块内存空间，有几个实例对象，就有几块内存空间。</p>
<h4 id="实例变量">实例变量</h4>
<p>在创建Java对象时都需要为实例变量分配内存空间和初始化。</p>
<p>在Java语法中有3个地方可以对实例变量初始化</p>
<ol>
<li>定义实例变量时指定初始化</li>
<li>在非静态的代码块对实例变量初始化</li>
<li>在构造器中对实例变量指定初始化</li>
</ol>
<blockquote>
<p>上面3个方式中，1.2方法永远比3方法执行的早，1.2方法的顺序与他们在源代码中顺序一致</p>
</blockquote>
<p>注：定义实例变量时指定的初始值、初始化块中为实例变量指定的初始值、构造器中为实例变量指定的初始值，三者的作用完全类似，都用于对实例变量指定初始值。经过编译器处理之后，它们对应的赋值语句都被合并到构造器中。在合并过程中，定义变量语句转换得到的赋值语句、初始化块里的语句转换得到的赋值语句，总是位于构造器的所有语句之前；合并后，两种赋值语句的顺序保持它们在源代码中的顺序。</p>
<h5 id="成员变量">成员变量</h5>
<h5 id="局部变量">局部变量</h5>
<ul>
<li>形参</li>
<li>方法中的局部变量： 在方法中显示初始化；初始化开始生效，随方法的结束和消亡。</li>
<li>代码块中的局部变量：在代码块中的显示初始化，初始化开始生效，随代码块的结束和消亡。</li>
</ul>
<p>局部变量作用的时间很短，被存储在方法的的栈内存</p>
<h4 id="类变量">类变量</h4>
<p>类变量属于Java类本身，只有程序在初始java类的时候才会对内变量分配内存空间和初始化。</p>
<p>在Java语法中有3个地方可以对类变量初始化</p>
<ol>
<li>定义类变量时指定初始化</li>
<li>静态代码快中对类变量指定初始值</li>
</ol>
<blockquote>
<p>以上俩种方式执行顺序和在源代码中的执行顺序一致</p>
</blockquote>
<pre><code class="language-Java">public class PriceTest {
    public static void main(String[] args) {

       System.out.println(Price.PIRCE.currentPice);
        // 以上输出结果为-2.8    从内存内存的角度看  1.初始化Price类  为类变量 PIRCE （默认值null）和  initPrice（默认值0） 分配内存空间  2.在初始实话代码块


        //17.2   这个情况是   Price类初始化一遍了（先内存角度  在逻辑角度）     在调用方法
        System.out.println( new Price(2.8).currentPice);
        System.out.println(Price.PIRCE.currentPice);
    }
}

class Price{
     static Price PIRCE = new Price(2.8);
    //  默认的初始化的赋值语句最好卸载最前面
    final   static double initPrice = 20;
    double currentPice;
    public Price(double discount){
        currentPice = initPrice-discount;
    }
}
</code></pre>
<h3 id="父类构造器">父类构造器</h3>
<p>当初创建任何Java对象时，程序总会依次调用每一个父类非静态代码初始块和父类构造器（总是从Object开始）执行初始化，最后才调用本类的非静态初始化块，构造器器执行初始化。</p>
<p>在创建Java对象时，至于调用父类的拿个构造器执行初始化分为以下几种情况：</p>
<ul>
<li>子类构造器执行中既没有super调用也没有this调用，系统将默认隐式调用父类无参构造器。</li>
<li>子类构造器中第一行代码使用super显示调用父类构造器，系统将根据super调用里传入参数列表确定调用父类的哪个构造器。</li>
<li>子类构造器中第一行代码使用this显式调用本类中重载的构造器，系统将根据this调用的参数列表确定本类的另一个构造器（开始进入的第二种情况）</li>
</ul>
<blockquote>
<p>注：super可以显式的调用父类构造器，this可以显式的调用本类的另一个构造器。super和this调用只能在构造器的第一行代码使用，因此构造器中只能只用super和this其中一个，而且最多使用一次</p>
</blockquote>
<h4 id="访问子类对象的实例变量">访问子类对象的实例变量</h4>
<p>子类可以访问父类方法和成员变量，这是因为父类的成员变量和方法都会被子类继承，但是父类无法访问子类的成员变量和方法。因为父类无法得知它是被那个子类继承。</p>
<p>极端情况会出一个情况</p>
<pre><code class="language-java">public class BaseTest {

    public static void main(String[] args) {
        new Derived();//输出结果为 2 0
        //创建Derived 对象实例时候  子类中会默认调用父类的无参构造   此时在父类的无参构造方法中，this代表的事子类实例对象。
      
    }
}

class Base{
    private  int i = 2;

    public Base(){
        System.out.println(this.i);
        this.display();
        System.out.println(this.getClass());
        //this.
    }

    public void display(){
        System.out.println(&quot;父类方法i=&quot;+i);
    }
}

class Derived extends Base{
    private int i = 22;

    public Derived(){
        i = 222;
    }
    @Override
    public void display(){
        System.out.println(&quot;子类方法i=&quot;+i);
    }
}
</code></pre>
<blockquote>
<p>刚开始的学习Java对象我们就知道Java对象是由构造器创建；</p>
<p>但是实际情况：构造器只负责对Java对象实例变量执行官初始化（赋值）由于在执行构造器代码之前，该对象所占用的内幕才能已经被分配下来，在这些内存中值都是空值，基本数据类型的默认值空值为0和false，引用类型为null。</p>
</blockquote>
<p>以上代码中 开始创建Derived对象，系统开始为对象分配内存空间，该内存需要存放俩个实例变量i，一个属于父类，一个属于子类。并且值为0；代码继续执行，在父类的Base构造中可以把代码执行情况</p>
<pre><code class="language-java">i = 2;
System.out.println(this.i);
this.display();
System.out.println(this.getClass());

输出结果 2 0
</code></pre>
<p>由代码this.getCLass 输出得知this为子类Derived 因此代码this.display();输出为子类的方法，但是子类的构造器还没执行到 子类i实例为控制0，输出为0；但是this.i 输出结果2（父类实例i）</p>
<p>仔细会发现，其实在以上代码中编译时期和与运行时期this代表的类型不一致：</p>
<p>当变量的编译时类型和运行时类型不同时，通过该变量访问它引用的对象的实例变量时，该实例变量的值由声明该变量的类型决定。但通过该变量调用它引用的对象的实例方法时，该方法行为将由它实际所引用的对象来决定。因此，当程序访问this.i时，将会访问Base类中定义的i实例变量，也就是将输出2；但执行this.display();代码时，则实际表现出Derived对象的行为，也就是输出Derived对象的i实例变量，即0。</p>
<h4 id="调用被子类重写的方法">调用被子类重写的方法</h4>
<p>如果父类构造器调用了被子类重写的方法，且通过子类的构造器来创建的子类对象，调用了这个父类构造器，就会导致子类的重写方法在子类的构造器代码之前执行，从而导致子类的重写方法访问不到实例变量值得情况。</p>
<pre><code class="language-java">package fengKuangJava;

/**
 * 父类访问子类的重写的方法情况
 *
 */
public class Animal1Test {

}

class Animal11{
    private int id;

    public Animal11(){
        this.id = id;
        this.desc();
    }
    public  void desc(){
        System.out.println(id);
    }

}

class Wolf1 extends Animal11{
    private String name;
    private int age;

    public Wolf1(String name,int age){
        this.name = name;
        this.age = age;
       // this.desc();
    }


    @Override
    public void desc(){
        System.out.println(name+age);
    }

    public static void main(String[] args) {
        new Wolf1(&quot;张三&quot;,1);
    }

}
</code></pre>
<h3 id="父子实例的内存控制">父子实例的内存控制</h3>
<h4 id="继承成员变量和继承方法的区别">继承成员变量和继承方法的区别</h4>
<p>如果子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。</p>
<p>对于实例变量则不存在这样的现象，即使子类中定义了与父类完全同名的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量。</p>
<p>因为继承成员变量和继承方法之间存在这样的差别，所以对于一个引用类型的变量而言，当通过该变量访问它所引用的对象的实例变量时，该实例变量的值取决于声明该变量时类型；当通过该变量来调用它所引用的对象的方法时，该方法行为取决于它所实际引用的对象的类型。</p>
<h4 id="内存中子类实例变量">内存中子类实例变量</h4>
<p>当程序创建一个子类对象时，系统不仅会为该类中定义的实例变量分配内存，也会为其父类中定义的所有实例变量分配内存，即使子类定义了与父类中同名实例变量。</p>
<p>也就是说，当系统创建一个Java对象时候，如果该Java类有两个父类（一个直接父类A，一个间接父类B），假设A类中定义了2个实例变量， B类中定义了3个实例变量，当前类中定义了2个实例变量，那这个Java对象将会保存2+3+2个实例变量。</p>
<p>如果在子类里定义了与父类中已有变量同名的变量，那么子类中定义的变量会隐藏父类中定义的变量。注意不是完全覆盖，因此系统为创建子类对象时，依然会为父类中定义的、被隐藏的变量分配内存空间。</p>
<p>为了在子类方法中访问父类中定义的、被隐藏的实例变量，或者为了在子类方法中调用父类中定义的、被覆盖（Override）的方法，可以通过super.作为限定来修饰这些实例变量和实例方法。因为子类中定义与父类中同名的实例变量并不会完全覆盖父类中定义的实例变量，它只是简单地隐藏了父类中的实例变量，所以会出现如下特殊的情形。</p>
<h4 id="父子类的类变量">父子类的类变量</h4>
<p>理解了上面介绍的父、子实例在内存中分配之后，接下来的父、子类的类变量基本与此类似。不同的是，类变量属于类本身，而实例变量则属于Java对象；类变量在类初始化阶段完成初始化，而实例变量则在对象初始化阶段完成初始化。</p>
<p>由于类变量本质上属于类本身，因此通常不会涉及父、子实例变量那样复杂的情形，但由于Java 允许通过对象来访问类变量，因此也可以使用super.作为限定来访问父类中定义的类变量</p>
<h3 id="final-修饰符">final 修饰符</h3>
<blockquote>
<ul>
<li>Final 修饰变量，被final修饰的变初始化之后，不能对它重新复制</li>
<li>final修饰方法，不能重写</li>
<li>final修饰类，不能被继承</li>
</ul>
</blockquote>
<h4 id="final修饰的变量">final修饰的变量</h4>
<p>对于一个使用final修饰的变量而言，如果定义该final变量时就指定初始值，而且这个初始值可以在编译时就确定下来（即形如2、2.3、“crazyit.org”这样的直接量），那么这个final变量将不再是一个变量，系统会将其当成“宏变量”处理。也就是说，所有出现该变量的地方，系统将直接把它当成对应的值处理。</p>
<h5 id="执行宏替换的变量">执行‘’宏替换“的变量</h5>
<p>对一个final变量，不管它是类变量、实例变量，还是局部变量，只要定义该变量时使用了final修饰符修饰，并在定义该final类变量时指定了初始值，而且该初始值可以在编译时就被确定下来，那么这个final变量本质上已经不再是变量，而是相当于一个直接量。</p>
<blockquote>
<p>Final 修饰符的一个重要用途就是定义”宏变量“，当定义final变量时就为该变量指定初始值，而且该初始值可以编译时就确定下来，那这个final变量本质就是一个宏变量，编译器会把程序中所有用到该变量的低脂肪直接替换成该变量的值。</p>
<p>除了上面那种为final变量赋值时赋直接量的情况外，如果被赋的表达式只是基本的算术运算表达式或字符串连接运算，没有访问普通变量，调用方法，Java编译器同样会将这种final变量当成“宏变量”处理</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反射相关的理解 ]]></title>
        <id>https://gguoliang.github.io/post/fan-she-xiang-guan-de-li-jie/</id>
        <link href="https://gguoliang.github.io/post/fan-she-xiang-guan-de-li-jie/">
        </link>
        <updated>2020-04-23T06:51:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="反射相关的理解">反射相关的理解</h3>
<p>Java 的<strong>反射机制</strong>是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； 并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。</p>
<h5 id="正射">正射</h5>
<p>创建类的Java对象</p>
<pre><code class="language-java"> Student student  = new Student();
 System.out.println(student.doWork(&quot;数学&quot;));

</code></pre>
<h5 id="反射">反射</h5>
<pre><code class="language-java"> // 获取类的class对象
 Student student1 = new Student();
 Class clazz = student1.getClass();
// 获取类的构造器
 Constructor constructor = clazz.getConstructor();
// 创建类的实例对象
 Object object = constructor.newInstance();
// 获取类的方法
 Method doWork = clazz.getMethod(&quot;doWork&quot;, String.class);
 System.out.println(doWork.invoke(object,&quot;语文&quot;));
</code></pre>
<p>上面的俩段代码作用正好从正反俩方面创建类的实例对象</p>
<h4 id="class对象理解">class对象理解</h4>
<p><strong>一个类对应一个class对象但是对应多个实例对象（Java对象</strong>）</p>
<p><strong>Class类的对象作用</strong>是运行时提供或获得某个对象的类型信息</p>
<h4 id="反射基本使用">反射基本使用</h4>
<h6 id="获取反射中的class对象三种方法">获取反射中的class对象三种方法</h6>
<pre><code class="language-java">获取class对象的三种方法 
 1.Class.forName(&quot;&quot;) 方法  
   Class clazz = Class.forName(&quot;javaSE.Student&quot;);
 2.类的.clsss 方法   
   Class clazz = Student.class;
 3.实例对象的.getClass() 方法
   Student student1 = new Student();
   Class clazz = student1.getClass();
</code></pre>
<h6 id="反射获取构造器">反射获取构造器</h6>
<pre><code class="language-java">//Student类的构造器
  public Student() {
        super();
    }

    public Student(long id, String name, int age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }

// 反射获取类的构造器 （这俩个方法都有参数和不带参数俩种） 
//1.clazz.getConstructor() 只能获取public的方法
   Constructor constructor1 = clazz.getConstructor();
//2.clazz.getDeclaredConstructors()
   Constructor[] declaredConstructors 
     =clazz.getDeclaredConstructors();
     for (int i = 0; i &lt; declaredConstructors.length; i++) {
        System.out.println(declaredConstructors[i]);
     }
//3.带参数clazz.getConstructor() 只能获取public的方法
Constructor constructor2 
  = clazz.getConstructor(Integer.class, String.class, Integer.class);
//4.带参数clazz.getDeclaredConstructors()  
Constructor declaredConstructor 
  = clazz.getDeclaredConstructor(Integer.class, String.class, Integer.class);

</code></pre>
<h6 id="反射创建实例对象">反射创建实例对象</h6>
<pre><code class="language-Java"> // 反射创建对象的方式 
 //1.通过class对象的newInstance()  
 Student student2 = (Student) clazz.newInstance();
 System.out.println(doWork.invoke(student2,&quot;体育&quot;));
 //2.constructor的newInstance()
 Object object = constructor.newInstance();
 System.out.println(doWork.invoke(object,&quot;语文&quot;));

</code></pre>
<h6 id="反射获取类的成员变量">反射获取类的成员变量</h6>
<pre><code class="language-Java">1. Field[] fields = clazz.getFields();// 获取类的所有public成员变量
2. Field declaredField = clazz.getDeclaredField(&quot;name&quot;);
3. Field name = clazz.getField(&quot;name&quot;); // 根绝name获取类的public成员变量
4. Field[] declaredFields = clazz.getDeclaredFields();
</code></pre>
<h6 id="反射获取类的方法">反射获取类的方法</h6>
<pre><code class="language-java">1. Method[] methods = clazz.getMethods();// 获取类的public方法
2. clazz.getMethod(&quot;name&quot;,String.class);// 获取类的name方法
3. Method[] declaredMethods = clazz.getDeclaredMethods();
4 .clazz.getDeclaredMethod(&quot;name&quot;,String.class);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac Item2自动远程连接服务器]]></title>
        <id>https://gguoliang.github.io/post/mac-item2-zi-dong-yuan-cheng-lian-jie-fu-wu-qi/</id>
        <link href="https://gguoliang.github.io/post/mac-item2-zi-dong-yuan-cheng-lian-jie-fu-wu-qi/">
        </link>
        <updated>2020-04-21T15:33:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="mac-item2自动远程连接服务器">Mac Item2自动远程连接服务器</h3>
<p>1.编写脚本</p>
<p>vi  test</p>
<pre><code class="language-python">#!/usr/bin/expect

set PORT 端口
set HOST ip
set USER root
set PASSWORD 密码

spawn ssh -p $PORT $USER@$HOST
expect {
        &quot;yes/no&quot; {send &quot;yes\r&quot;;exp_continue;}
         &quot;*password:*&quot; { send &quot;$PASSWORD\r&quot; }
        }
interact

</code></pre>
<p>2.配置文件</p>
<p>Prefences —&gt; Profiles 中 新增 profile</p>
<p>在新增的profile设置command 选择command 后面跟 expect +（第一步新建文件地址）</p>
]]></content>
    </entry>
</feed>